/*
Copyright 2022 EscherCloud.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package constants

import (
	"log"
	"os"
	"reflect"
	"time"
)

var (
	Version     = "v0.0.2-beta1"
	SupportedOS = []string{
		"ubuntu-2004",
		"ubuntu-2204",
	}
	requiredVars = map[string]string{
		"AuthURL":            "OS_AUTH_URL",
		"ProjectName":        "OS_PROJECT_NAME",
		"ProjectID":          "OS_PROJECT_ID",
		"Username":           "OS_USERNAME",
		"Password":           "OS_PASSWORD",
		"Region":             "OS_REGION_NAME",
		"Interface":          "OS_INTERFACE",
		"UserDomainName":     "OS_USER_DOMAIN_NAME",
		"ProjectDomainName":  "OS_PROJECT_DOMAIN_NAME",
		"IdentityAPIVersion": "OS_IDENTITY_API_VERSION",
		"AuthPlugin":         "OS_AUTH_PLUGIN",
	}
	Envs = &OpenstackEnvs{}
)

// Year is used in reports parsing. It is the top level and contains multiple Month(s).
type Year struct {
	Months map[string]Month
}

// Month is used in reports parsing. It is contained within a Year and contains multiple ReportData(s).
type Month struct {
	Reports map[string]ReportData
}

// ReportData is a struct representation of a report that is generated by Trivy.
// It is used for parsing and generating the static sites.
type ReportData struct {
	Name          string `json:"name"`
	ShortName     string `json:"short_name"`
	SchemaVersion int    `json:"schema_version"`
	ArtifactName  string `json:"artifact_name"`
	ArtifactType  string `json:"artifact_type"`
	Metadata      struct {
		OS struct {
			Family string `json:"family"`
			Name   string `json:"name"`
		} `json:"os"`

		ImageConfig struct {
			Architecture string    `json:"architecture"`
			Created      time.Time `json:"created"`
			Os           string    `json:"os"`
			Rootfs       struct {
				Type    string      `json:"type"`
				DiffIds interface{} `json:"diff_ids"`
			} `json:"rootfs"`
			Config struct {
			} `json:"config"`
		} `json:"ImageConfig"`
	} `json:"metadata"`

	Results []struct {
		Target          string `json:"Target"`
		Class           string `json:"Class"`
		Type            string `json:"Type,omitempty"`
		Vulnerabilities []struct {
			VulnerabilityID  string `json:"VulnerabilityID"`
			PkgName          string `json:"PkgName"`
			InstalledVersion string `json:"InstalledVersion"`
			Layer            struct {
			} `json:"Layer"`
			SeveritySource string `json:"SeveritySource,omitempty"`
			PrimaryURL     string `json:"PrimaryURL"`
			DataSource     struct {
				ID   string `json:"ID"`
				Name string `json:"Name"`
				URL  string `json:"URL"`
			} `json:"DataSource"`
			Title       string   `json:"Title,omitempty"`
			Description string   `json:"Description"`
			Severity    string   `json:"Severity"`
			CweIDs      []string `json:"CweIDs,omitempty"`
			CVSS        struct {
				Nvd struct {
					V2Vector string  `json:"V2Vector,omitempty"`
					V3Vector string  `json:"V3Vector,omitempty"`
					V2Score  float64 `json:"V2Score,omitempty"`
					V3Score  float64 `json:"V3Score,omitempty"`
				} `json:"nvd,omitempty"`
				Redhat struct {
					V3Vector string  `json:"V3Vector,omitempty"`
					V3Score  float64 `json:"V3Score,omitempty"`
					V2Vector string  `json:"V2Vector,omitempty"`
					V2Score  float64 `json:"V2Score,omitempty"`
				} `json:"redhat,omitempty"`
				Ghsa struct {
					V3Vector string  `json:"V3Vector"`
					V3Score  float64 `json:"V3Score"`
				} `json:"ghsa,omitempty"`
			} `json:"CVSS,omitempty"`
			References       []string  `json:"References"`
			PublishedDate    time.Time `json:"PublishedDate,omitempty"`
			LastModifiedDate time.Time `json:"LastModifiedDate,omitempty"`
			PkgPath          string    `json:"PkgPath,omitempty"`
			FixedVersion     string    `json:"FixedVersion,omitempty"`
		} `json:"Vulnerabilities,omitempty"`
		Secrets []struct {
			RuleID    string `json:"RuleID"`
			Category  string `json:"Category"`
			Severity  string `json:"Severity"`
			Title     string `json:"Title"`
			StartLine int    `json:"StartLine"`
			EndLine   int    `json:"EndLine"`
			Code      struct {
				Lines []struct {
					Number      int    `json:"Number"`
					Content     string `json:"Content"`
					IsCause     bool   `json:"IsCause"`
					Annotation  string `json:"Annotation"`
					Truncated   bool   `json:"Truncated"`
					Highlighted string `json:"Highlighted,omitempty"`
					FirstCause  bool   `json:"FirstCause"`
					LastCause   bool   `json:"LastCause"`
				} `json:"Lines"`
			} `json:"Code"`
			Match   string `json:"Match"`
			Deleted bool   `json:"Deleted"`
			Layer   struct {
			} `json:"Layer"`
		} `json:"Secrets,omitempty"`
	} `json:"Results"`
}

// OpenstackEnvs is used to store all variables passed to the program.
type OpenstackEnvs struct {
	AuthURL            string
	ProjectName        string
	ProjectID          string
	Username           string
	Password           string
	Region             string
	Interface          string
	UserDomainName     string
	ProjectDomainName  string
	IdentityAPIVersion string
	AuthPlugin         string
}

// SetOpenstackEnvs sets the Openstack environment variable for the system to use.
// This is required because the make command won't take the flags. Later we'll try to generate a clouds.yaml file.
func (e *OpenstackEnvs) SetOpenstackEnvs() {
	for k, v := range requiredVars {
		setEnv(v, reflect.ValueOf(e).Elem().FieldByName(k).String())
	}
}

// setEnv sets an environment variable
func setEnv(key string, value string) {
	err := os.Setenv(key, value)
	if err != nil {
		log.Fatalln(err)
	}
}

// CheckForEnvVars runs through all the possible Environment vars defined in the OpenstackEnvs struct and determines if an
// EnvVar has been set via a flag being passed into the application.
// If it has, it will register it in OpenstackEnvs.
//func (e *OpenstackEnvs) CheckForEnvVars() {
//	for k, v := range requiredVars {
//		if !checkEnv(e, k, v) {
//			log.Fatalf("%s is missing - cannot continue. Please ensure the flag is passed.", v)
//		}
//	}
//}

// checkEnv will determine if a flag or environment variable is passed into the program.
// If a flag is passed in, it will ensure the corresponding Environment variable exists.
// If a flag hasn't been passed, it will attempt to discover the value from an Environment variable,
// should it not find one - and a default isn't available, the program will fail.
//func checkEnv(envs *OpenstackEnvs, field, envVar string) bool {
//	if v, ok := os.LookupEnv(envVar); ok {
//		reflect.ValueOf(envs).Elem().FieldByName(field).SetString(v)
//	} else {
//		err := os.Setenv(field, reflect.ValueOf(envs).Elem().FieldByName(field).String())
//		if err != nil {
//			return false
//		}
//	}
//	return true
//}
