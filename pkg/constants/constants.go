/*
Copyright 2022 EscherCloud.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package constants

import (
	"log"
	"os"
	"reflect"
	"time"
)

var Version = "v0.0.2-beta1"

// Year is used in reports parsing. It is the top level and contains multiple Month(s).
type Year struct {
	Months map[string]Month
}

// Month is used in reports parsing. It is contained within a Year and contains multiple ReportData(s).
type Month struct {
	Reports map[string]ReportData
}

// ReportData is a struct representation of a report that is generated by Trivy.
// It is used for parsing and generating the static sites.
type ReportData struct {
	Name          string `json:"name"`
	SchemaVersion int    `json:"schema_version"`
	ArtifactName  string `json:"artifact_name"`
	ArtifactType  string `json:"artifact_type"`
	Metadata      struct {
		OS struct {
			Family string `json:"family"`
			Name   string `json:"name"`
		} `json:"os"`

		ImageConfig struct {
			Architecture string    `json:"architecture"`
			Created      time.Time `json:"created"`
			Os           string    `json:"os"`
			Rootfs       struct {
				Type    string      `json:"type"`
				DiffIds interface{} `json:"diff_ids"`
			} `json:"rootfs"`
			Config struct {
			} `json:"config"`
		} `json:"ImageConfig"`
	} `json:"metadata"`

	Results []struct {
		Target          string `json:"Target"`
		Class           string `json:"Class"`
		Type            string `json:"Type,omitempty"`
		Vulnerabilities []struct {
			VulnerabilityID  string `json:"VulnerabilityID"`
			PkgName          string `json:"PkgName"`
			InstalledVersion string `json:"InstalledVersion"`
			Layer            struct {
			} `json:"Layer"`
			SeveritySource string `json:"SeveritySource,omitempty"`
			PrimaryURL     string `json:"PrimaryURL"`
			DataSource     struct {
				ID   string `json:"ID"`
				Name string `json:"Name"`
				URL  string `json:"URL"`
			} `json:"DataSource"`
			Title       string   `json:"Title,omitempty"`
			Description string   `json:"Description"`
			Severity    string   `json:"Severity"`
			CweIDs      []string `json:"CweIDs,omitempty"`
			CVSS        struct {
				Nvd struct {
					V2Vector string  `json:"V2Vector,omitempty"`
					V3Vector string  `json:"V3Vector,omitempty"`
					V2Score  float64 `json:"V2Score,omitempty"`
					V3Score  float64 `json:"V3Score,omitempty"`
				} `json:"nvd,omitempty"`
				Redhat struct {
					V3Vector string  `json:"V3Vector,omitempty"`
					V3Score  float64 `json:"V3Score,omitempty"`
					V2Vector string  `json:"V2Vector,omitempty"`
					V2Score  float64 `json:"V2Score,omitempty"`
				} `json:"redhat,omitempty"`
				Ghsa struct {
					V3Vector string  `json:"V3Vector"`
					V3Score  float64 `json:"V3Score"`
				} `json:"ghsa,omitempty"`
			} `json:"CVSS,omitempty"`
			References       []string  `json:"References"`
			PublishedDate    time.Time `json:"PublishedDate,omitempty"`
			LastModifiedDate time.Time `json:"LastModifiedDate,omitempty"`
			PkgPath          string    `json:"PkgPath,omitempty"`
			FixedVersion     string    `json:"FixedVersion,omitempty"`
		} `json:"Vulnerabilities,omitempty"`
		Secrets []struct {
			RuleID    string `json:"RuleID"`
			Category  string `json:"Category"`
			Severity  string `json:"Severity"`
			Title     string `json:"Title"`
			StartLine int    `json:"StartLine"`
			EndLine   int    `json:"EndLine"`
			Code      struct {
				Lines []struct {
					Number      int    `json:"Number"`
					Content     string `json:"Content"`
					IsCause     bool   `json:"IsCause"`
					Annotation  string `json:"Annotation"`
					Truncated   bool   `json:"Truncated"`
					Highlighted string `json:"Highlighted,omitempty"`
					FirstCause  bool   `json:"FirstCause"`
					LastCause   bool   `json:"LastCause"`
				} `json:"Lines"`
			} `json:"Code"`
			Match   string `json:"Match"`
			Deleted bool   `json:"Deleted"`
			Layer   struct {
			} `json:"Layer"`
		} `json:"Secrets,omitempty"`
	} `json:"Results"`
}

// Env is used to store all variables passed to the program.
type Env struct {
	AuthURL                  string
	ProjectName              string
	ProjectID                string
	Username                 string
	Password                 string
	Region                   string
	Interface                string
	UserDomainName           string
	ProjectDomainName        string
	IdentityAPIVersion       string
	AuthPlugin               string
	NetworkID                string
	ServerFlavorID           string
	OpenstackBuildConfigPath string
	EnableConfigDrive        string
	ImageRepo                string
	BuildOS                  string
	GhUser                   string
	GhProject                string
	GhToken                  string
	GhPagesBranch            string
}

// checkEnv will determine if a flag or environment variable is passed into the program.
// If a flag is passed in, it will ensure the corresponding Environment variable exists.
// If a flag hasn't been passed, it will attempt to discover the value from an Environment variable,
// should it not find one - and a default isn't available, the program will fail.
func checkEnv(envs *Env, field, envVar string) bool {
	value := reflect.ValueOf(envs).Elem().FieldByName(field)
	if value.String() == "" {
		if key, ok := os.LookupEnv(envVar); ok {
			reflect.ValueOf(envs).Elem().FieldByName(field).SetString(key)
		} else {
			return false
		}
	} else {
		err := os.Setenv(envVar, value.String())
		if err != nil {
			log.Printf("couldn't set env var %s.\n", envVar)
			return false
		}
	}
	return true
}

// CheckForEnvVars runs through all the possible Environment vars defined in the Env struct and determines if a
// flag of Env var has been passed into the program.
// If it has, it will register it in the Env.
func (e *Env) CheckForEnvVars() {
	canContinue := true

	//TODO: this is horrid, there must be a better reflective way I haven't considered by which I can loop over.
	if !checkEnv(e, "AuthURL", "OS_AUTH_URL") {
		canContinue = false
	}
	if !checkEnv(e, "ProjectName", "OS_PROJECT_NAME") {
		canContinue = false
	}
	if !checkEnv(e, "ProjectID", "OS_PROJECT_ID") {
		canContinue = false
	}
	if !checkEnv(e, "Username", "OS_USERNAME") {
		canContinue = false
	}
	if !checkEnv(e, "Password", "OS_PASSWORD") {
		canContinue = false
	}
	if !checkEnv(e, "Region", "OS_REGION_NAME") {
		canContinue = false
	}
	if !checkEnv(e, "Interface", "OS_INTERFACE") {
		canContinue = false
	}
	if !checkEnv(e, "UserDomainName", "OS_USER_DOMAIN_NAME") {
		canContinue = false
	}
	if !checkEnv(e, "ProjectDomainName", "OS_PROJECT_DOMAIN_NAME") {
		canContinue = false
	}
	if !checkEnv(e, "IdentityAPIVersion", "OS_IDENTITY_API_VERSION") {
		canContinue = false
	}
	if !checkEnv(e, "AuthPlugin", "OS_AUTH_PLUGIN") {
		canContinue = false
	}
	if !checkEnv(e, "NetworkID", "OS_NETWORK_ID") {
		canContinue = false
	}
	if !checkEnv(e, "ServerFlavorID", "OS_SERVER_FLAVOR_ID") {
		canContinue = false
	}
	if !checkEnv(e, "EnableConfigDrive", "OS_ENABLE_CONFIG_DRIVE") {
		canContinue = false
	}
	if !checkEnv(e, "OpenstackBuildConfigPath", "OS_BUILD_CONFIG") {
		canContinue = false
	}
	if !checkEnv(e, "ImageRepo", "IMAGE_REPO") {
		canContinue = false
	}
	if !checkEnv(e, "BuildOS", "BUILD_OS") {
		canContinue = false
	}
	if !checkEnv(e, "GhUser", "GH_USER") {
		canContinue = false
	}
	if !checkEnv(e, "GhProject", "GH_PROJECT") {
		canContinue = false
	}
	if !checkEnv(e, "GhToken", "GH_TOKEN") {
		canContinue = false
	}
	if !checkEnv(e, "GhPagesBranch", "GH_PAGES_BRANCH") {
		canContinue = false
	}

	if !canContinue {
		panic("some required variables are missing - cannot continue")
	}
}
